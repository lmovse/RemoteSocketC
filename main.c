#include <reg52.h>
#include <string.h>

#define RELOAD_COUNT 0XFD
#define DS1302_READ_ADDR 0X81//DS1302 读取数据地址
#define	DS1302_WRITE_ADDR 0X80//DS1302 写入数据地址
#define uchar unsigned char
#define uint unsigned int

sbit SCLK = P1^0;//定义 DS1302 时钟引脚
sbit IO = P1^1;//定义 DS1302 数据引脚
sbit RST = P1^2;//DS1302 使能引脚
sbit S1 = P1^3;//定义插线板插口 1 继电器引脚
sbit S2 = P1^4;//定义插线板插口 2 继电器引脚
sbit S3 = P1^5;//定义插线板插口 3 继电器引脚
sbit S4 = P1^6;//定义插线板插口 4 继电器引脚

uchar Receive;//定义字节接收变量									 
uchar State[] = "0000"; //定义继电器初始状态
uchar Timing[4][7];//定义四路继电器定时数组
uchar Receive_table[30]; //接收 WiFi 模块发送的数据
uchar Time_table[] = {12, 5, 5, 14, 12, 3, 16}; //时间初始化数组
uchar Alarm_table[7]; //接收闹钟信息，格式为时分秒
uchar code CIPMUX[] = "AT+CIPMUX=1"; //ESP8266 打开多连接
uchar code CIPSERVER[] = "AT+CIPSERVER=1,8080"; //打开服务器，端口为 8080
uchar code CIPSEND[] = "AT+CIPSEND=0,9"; //进入发送模式，发送对象为 0，发送长度为 9
uchar code CIPSEND1[] = "AT+CIPSEND=0,14";//进入发送模式，发送对象为 0，发送长度为 14

/*****************************************************************************
函数名称：Delay_Ms(uint ms)
函数功能：ms 级延时
输入参数：ms：所要延时时长
返回值：无
******************************************************************************/
void Delay_Ms(uint ms)
{
	uint p, y;
	for(p = ms; p > 0; p--)
		for(y = 112; y > 0; y--);
}

/*****************************************************************************
函数名称：DS1302_Write_Byte(uchar dat)
函数功能：向 DS1302 写入字节数据
输入参数：dat：所要发送的字节数据
返回值：无
******************************************************************************/
void DS1302_Write_Byte(uchar dat)
{
	uchar i;
	for(i = 0; i < 8; i++)
	{
	 	SCLK = 0;//拉低时钟端
		IO = dat & 0x01;//数据端写入数据
		SCLK = 1;//拉高时钟端，形成上升沿，写入数据
		dat >>= 1;	
	}
}

/*****************************************************************************
函数名称：DS1302_Read_Byte()
函数功能：从 DS1302 中读取字节数据
输入参数：无
返回值：uchar: 所读取的字节数据
******************************************************************************/
uchar DS1302_Read_Byte()
{
	uchar i,dat;
	for(i = 0; i < 8; i++)
	{
		SCLK = 0;//打的时钟端
		dat >>= 1;
		if(IO)
		{
			dat |= 0x80;//从数据端读取数据	
		}
		SCLK = 1;//拉高时钟端，形成上升沿，读取数据
	}
	return dat;
}

/*****************************************************************************
函数名称：DS1302_Write_Dat(uchar addr, uchar dat)
函数功能：向 DS1302 中的指定地址写入数据
输入参数：addr: 所要写入的地址。 dat: 要写入的数据
返回值：无
******************************************************************************/
void DS1302_Write_Dat(uchar addr, uchar dat)
{
	uchar dat1,dat2;
	dat1 = dat/10;//进行BCD编码
	dat2 = dat%10;
	dat1 <<= 4;
	dat = dat1 + dat2;
	RST = 0;//初始化使能端
	SCLK = 0;//初始化时钟端
	RST = 1;//拉高使能端，允许读写
	DS1302_Write_Byte(addr);//写入写数据地址
	DS1302_Write_Byte(dat);//写入数据
	RST = 0;//拉低使能端，禁止读写
}

/*****************************************************************************
函数名称：DS1302_Read_Dat(uchar addr)
函数功能：从 DS1302 中的指定地址读取时间数据，并保存在字符变量中
输入参数：addr: 所要读取的地址
返回值：uchar：所读取出的数据
******************************************************************************/
uchar DS1302_Read_Dat(uchar addr)
{
	uchar dat;
	RST = 0;//初始化使能端
	SCLK = 0;//初始化时钟端
	RST = 1;//拉高使能端，允许读写操作
	DS1302_Write_Byte(addr);//写入数据读取地址
	dat = DS1302_Read_Byte();//读取数据
	RST = 0;//拉低使能端，禁止读写操作
	return dat;
}

/*****************************************************************************
函数名称：DS1302_Open_Wp()
函数功能：打开 DS1302 写保护，禁止读取与写入数据
输入参数：无
返回值：无
******************************************************************************/
void DS1302_Open_Wp()
{
	DS1302_Write_Dat(0x8e, 0x80);
	RST = 0;//拉低使能端，禁止读写数据
	SCLK = 0;//初始化时钟端
}

/*****************************************************************************
函数名称：DS1302_Close_Wp()
函数功能：关闭 DS1302 写保护，允许读取与写入数据
输入参数：无
返回值：无
******************************************************************************/
void DS1302_Close_Wp()
{
	DS1302_Write_Dat(0x8e, 0);
}

/*****************************************************************************
函数名称：DS1302_Set_Time(uchar addr, uchar Time_table[])
函数功能：初始化 DS1302 时间
输入参数：addr: 所要写入时间的首地址，Time_table[]: 所要写入的时间数组
返回值：无
******************************************************************************/
void DS1302_Set_Time(uchar addr, uchar Time_table[])
{
	uchar i;
	DS1302_Close_Wp();//打开写保护，允许读写数据
	for(i = 0; i < 7; i++)
	{
		DS1302_Write_Dat(addr, Time_table[i]);//将时间数组中的数据写入指定地址中
		addr += 2;//地址向后移两位
	}
	DS1302_Open_Wp();//打开写保护，禁止读写数据
}

/*****************************************************************************
函数名称：DS1302_Read_Time(uchar addr, uchar Time_table[])
函数功能：从 DS1302 中的指定地址读取时间数据，并保存在字符数组中
输入参数：addr: 所要读取的地址，Time_table[]:保存读取出来的时间的字符数组
返回值：无
******************************************************************************/
void DS1302_Read_Time(uchar addr, uchar Time_table[])
{
	uchar i;
	DS1302_Close_Wp();//关闭写保护，允许读写数据
	for(i = 0; i < 7; i++)
	{
		Time_table[i] = DS1302_Read_Dat(addr);//从指定地址中读取出来数据，保存在 Time_table 中
		addr += 2;//地址向后移两位
	}
	DS1302_Open_Wp();//打开写保护，禁止读写数据
}

/*****************************************************************************
函数名称：Uart_Init()
函数功能：串行口初始化
输入参数：无
返回值：无
******************************************************************************/
void Uart_Init()
{
	SCON = 0X50;//8位异步收发，允许串行接收
	TMOD = 0X20;//定时器T1工作在方式2，8位常数自动重新装载的定时器
	TH1 = RELOAD_COUNT;//定时器1装载初值，波特率为 9600
	TL1 = RELOAD_COUNT;//定时器1装载初值，波特率为 9600
	TR1 = 1;//开定时器1
	ES = 1;//串口中断允许
	EA = 1;//总中断允许	
}

/*****************************************************************************
函数名称：Uart_Send_Char(uchar dat)
函数功能：串行口发送字节
输入参数：dat:要发送的字节数据
返回值：无
******************************************************************************/
void Uart_Send_Char(uchar dat)
{
	ES = 0;//关闭串口中断
	TI = 0;//清除发送标志
	SBUF = dat;//将要发送的数据存入 SBUF 缓冲区
	while(!TI);//等待发送完毕
	TI = 0;//清除发送标志
	ES = 1;//打开串口中断
}

/*****************************************************************************
函数名称：Uart_Send_String(uchar string[])
函数功能：串行口发送字符
输入参数：string[]:要发送的字符数据
返回值：无
******************************************************************************/
void Uart_Send_String(uchar string[])//串行口发送字符函数
{
	static uchar i = 0;
	while(string[i])
	{
		Uart_Send_Char(string[i++]);//串行口发送字节
	}
	Uart_Send_Char('\r');
	Uart_Send_Char('\n');//结束数据发送标志
	i = 0;//重置发送计数
	Delay_Ms(50);//等待串行口稳定总线
}

/*****************************************************************************
函数名称：Uart_Send_Array(uchar array[])
函数功能：串行口发送字符数组
输入参数：array[]:要发送的字符数组数据
返回值：无
******************************************************************************/
void Uart_Send_Array(uchar array[])//串行口发送字符数组函数
{
	static uchar i = 1;
	while(i < 7)
	{
		Uart_Send_Char(array[i]/16 + '0');//进行BCD解码
		Uart_Send_Char(array[i]%16 + '0');
		i++;
	}
	Uart_Send_Char('\r');
	Uart_Send_Char('\n');//结束数据发送标志
	i = 0;//重置发送计数
	Delay_Ms(50);//等待发送完毕，稳定总线
}

/*****************************************************************************
函数名称:ESP8266_Send_Array(uchar array[])
函数功能:通过ESP8266向远程端发送字符数组数据
输入参数：array[]:要发送的字符数组数据
返回值：无
******************************************************************************/
void ESP8266_Send_Array(uchar array[])
{
	Uart_Send_String(CIPSEND1);//打开 ESP 发送
	Uart_Send_Array(array);//发送字符数组数据
}

/*****************************************************************************
函数名称:ESP8266_Send(uchar puf[])
函数功能:通过ESP8266向远程端发送字符数据
输入参数：puf[]:要发送的字符数据
返回值：无
******************************************************************************/
void ESP8266_Send(uchar puf[])//ESP发送字符              
{
	Uart_Send_String(CIPSEND);//打开 ESP 发送
	Uart_Send_String(puf);//发送字节数据
}

/*****************************************************************************
函数名称:ESP8266_Send_Status()
函数功能:通过ESP8266向远程端发送继电器开关状态
输入参数：无
返回值：无
******************************************************************************/
void ESP8266_Send_Status()//发送继电器状态
{										 		
	(S1) ? (State[0] = '1') : (State[0] = '0');//查询继电器 1 状态
	(S2) ? (State[1] = '1') : (State[1] = '0');//查询继电器 2 状态
	(S3) ? (State[2] = '1') : (State[2] = '0');//查询继电器 3 状态
	(S4) ? (State[3] = '1') : (State[3] = '0');//查询继电器 4 状态
	Uart_Send_String("AT+CIPSEND=0,4");//打开 ESP 发送
	Uart_Send_String(State);//发送继电器状态
}


/*****************************************************************************
函数名称:setTiming(int i)
函数功能:设置相应继电器的定时数据
输入参数：i: 继电器序号
返回值：无
******************************************************************************/
void setTiming(int i)
{
	DS1302_Read_Time(DS1302_READ_ADDR, Timing[i]);//读取当前时间，并保存在相应数组中
	Timing[i - 1][2] = (Receive_table[11] - '0') * 10 + (Receive_table[12] - '0');//设置定时小时数据
	Timing[i - 1][1] = (Receive_table[14] - '0') * 10 + (Receive_table[15] - '0');//设置定时分钟数据
}

/*****************************************************************************
函数名称:set_Timing()
函数功能:定时判断，选择所要定时的继电器
输入参数：index:所选择的继电器序号
返回值：无
******************************************************************************/
void Set_Timing(char index)
{
	switch(index){
	   {
		case '1':
			setTiming(1);//对继电器 1 进行定时设置
			break;
		case '2':
			setTiming(2);
			break;
		case '3':
			setTiming(3);
			break;
		case '4':
			setTiming(4);
			break;
		default:
			break;
		}
	}
}

/*****************************************************************************
函数名称：HandlerData(char dat)
函数功能：主控制函数，根据所接收的数据进行判断后实现相应的功能
输入参数：dat:所要进行判断的数据
返回值：无
******************************************************************************/
void HandlerData(char dat)
{
	switch(dat)
	{
		case '1':
			S1 = ~S1; //S1 如果打开就关闭，如果关闭就打开
			(S1) ? (ESP8266_Send("S1 ClOSE")) : (ESP8266_Send("S1  OPEN"));//反馈当前状态给远程端		
			break;
		case '2':
			S2 = ~S2;
			(S2) ? (ESP8266_Send("S2 CLOSE")) : (ESP8266_Send("S2  OPEN"));			
			break;
		case '3':
			S3 = ~S3;
	    	(S3) ? (ESP8266_Send("S3 CLOSE")) : (ESP8266_Send("S3  OPEN"));			
			break;
		case '4':
			S4 = ~S4;
			(S4) ? (ESP8266_Send("S4 CLOSE")) : (ESP8266_Send("S4  OPEN"));			
			break;
		case 'k':
			ESP8266_Send_Status();//发送当前继电器开关状态
			break;
		case 'S':
			Set_Timing(Receive_table[10]);//进入定时判断函数	
			break;
		default:
			break;
	}
	Receive_table[9] = '\0';//处理完后清空接收数组
}

/*****************************************************************************
函数名称:Init()
函数功能:主程序的初始化函数，包括 DS1302、ESP8266 的初始化
输入参数：无
返回值：无
******************************************************************************/
void Init()
{
	Delay_Ms(5000); //上电延时一段时间，等待 ESP 稳定总线
	Uart_Init(); //串口初始化
	Uart_Send_String(CIPMUX); //打开 ESP 多连接
	Uart_Send_String(CIPSERVER); //打开服务器
	DS1302_Set_Time(DS1302_WRITE_ADDR, Time_table); //DS1302 初始化
} 
			 
void main()
{
	int t;
	Init();//初始化DS1302 与 ESP8266
	while(1)
	{
		for(t = 0; t < 4; t++)
		{
			DS1302_Read_Time(DS1302_READ_ADDR, Alarm_table);//读取当前时间
			if(!strcmp(Alarm_table, Timing[t]))//判断是否与某个定时数组时间相同
			{
				HandlerData(t + '0');//相同的话就转到主处理函数进行数据的判断与处理
			}
		}
		if((Receive_table[0] == '+') && (Receive_table[1] == 'I') && (Receive_table[2] == 'P') &&(Receive_table[3] == 'D') )//接收到的数据为+IPD时进入判断函数
		{
			Delay_Ms(100);//等待数据接收完毕
			HandlerData(Receive_table[9]);//判断与处理数据		
		}
	}  

}

/*****************************************************************************
函数名称：Uart_Interrupt() interrupt 4
函数功能：中断服务程序，读取出从远程端接收到的字节数据
输入参数：无
返回值：无
******************************************************************************/
void Uart_Interrupt() interrupt 4
{
	static i = 0;
	if(RI)//判断是否接收完毕
	{
		RI = 0;//接收标志位清零
		Receive = SBUF;//读取出数据
		Receive_table[i++] = Receive;//将数据保存在接收数据数组中
		if((Receive_table[i-1] == '\n') && (Receive_table[i-2] == '\r')) //数组接收完毕或者将满时将数组清零
		{
			i = 0;//清零接收计数
		}
	}

}
